<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>clothing.deals</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --text-color: #333;
            --bg-color: #fff;
            --accent-color: #07f;
            --border-color: #dee2e6;
            --stripe-color: #f8f9fa;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --progress-bg: #e9ecef;
            --progress-bar: #007bff;
            --nested-border-color: #e9ecef;
            --size: 100px;
        }
        body {
            font-family: var(--font-sans);
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        h1 {
            font-size: 1.5rem;
            font-weight: 400;
            margin: .5rem;
            text-align: center;
        }
        .site-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: var(--bg-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: .3rem;
            padding: .5rem;
            background: var(--stripe-color);
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, .1);
            justify-content: center;
        }
        .filter-group {
            display: flex;
            gap: .3rem;
        }
        label {
            display: block;
            font-size: .8rem;
            margin-bottom: .1rem;
            color: #495057;
            text-align: center;
        }
        input,
        select {
            padding: .3rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
            height: 1.5rem;
        }
        select#gender,
        select#sort_by {
            width: 6rem;
        }
        input#brand {
            width: 9rem;
        }
        input#size,
        input#color {
            width: 7rem;
        }
        input#min_price,
        input#max_price,
        input#min_discount {
            width: 3rem;
        }
        .group-header {
            cursor: pointer;
            padding: .3rem .5rem;
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        .group-header:hover {
            background: #e9ecef;
        }
        .group-header .toggle {
            width: .8rem;
            height: .8rem;
            margin-right: .4rem;
            font-size: .7rem;
            text-align: center;
            line-height: .8rem;
        }
        .product-table {
            border-left: 2px solid var(--nested-border-color);
        }
        table {
            border-collapse: collapse;
            font-size: .9rem;
            width: 100%;
            table-layout: fixed;
        }
        th,
        td {
            padding: .2rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
        }
        td.product-name,
        th.product-name {
            width: 20vw;
        }
        td.brand-name,
        th.brand-name {
            width: 10vw;
        }
        td.sizes-cell {
            width: 8vw;
        }
        td.price-cell,
        th.price-cell {
            width: 60px;
        }
        td.discount,
        th.discount {
            width: 6vw;
            text-align: center;
        }
        td.discount {
            font-weight: 600;
        }
        td.image-cell {
            width: var(--size);
            height: var(--size);
            position: relative;
            overflow: visible;
        }
        .image-wrapper {
            position: relative;
            height: var(--size);
            width: var(--size);
        }
        .product-thumbnail {
            width: var(--size);
            height: var(--size);
            object-fit: contain;
            cursor: pointer;
            display: block;
            border-radius: 3px;
            background-color: transparent;
        }
        .image-wrapper.expanded {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: auto;
            height: auto;
            z-index: 10;
        }
        .image-wrapper.expanded .product-thumbnail {
            width: auto;
            height: auto;
            max-width: 80vw;
            max-height: 80vh;
            border: 2px solid white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            background-color: var(--bg-color);
        }
        .lazy-image-placeholder {
            width: var(--size);
            height: var(--size);
            border-radius: 3px;
            background-color: transparent;
        }
        td.description-cell {
            width: 10vw;
            white-space: pre-wrap;
        }
        .description-content {
            max-height: 6em;
            overflow: hidden;
        }
        th {
            background: var(--stripe-color);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .image-nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 11;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
        }
        .image-nav-arrow:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        .image-nav-arrow.left {
            left: 5px;
        }
        .image-nav-arrow.right {
            right: 5px;
        }
                tr:nth-child(even) {
            background: var(--stripe-color);
        }
        tr:hover {
            background: #e9ecef;
        }
        a {
            color: var(--accent-color);
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .hidden {
            display: none;
        }
        .progress-container {
            width: 100%;
            max-width: 400px;
            height: 4px;
            background: var(--progress-bg);
            border-radius: 2px;
            margin: .5rem auto;
            overflow: hidden;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 100%;
            background: var(--progress-bar);
            animation: indeterminate 1.5s linear infinite;
        }
        @keyframes indeterminate {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }
        .load-sentinel {
            height: 50px;
        }
    </style>
</head>
<body>
    <h1>clothing.deals</h1>
    <header class="site-header">
        <div class="progress-container" id="progress-container">
            <div class="progress-bar"></div>
        </div>
        <form id="filters" onsubmit="return false;">
            <div class="filter-group">
                <div>
                    <label for="gender">Gender</label>
                    <select id="gender">
                        <option value="men">Men</option>
                        <option value="women">Women</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div>
                    <label for="size">Size</label>
                    <input type="text" id="size" placeholder="XS, 32, 8.5...">
                </div>
                <div>
                    <label for="brand">Brand</label>
                    <input type="text" id="brand" placeholder="Nike, Burberry..." list="brand-list">
                </div>
            </div>
            <div class="filter-group">
                <div>
                    <label for="color">Color</label>
                    <input type="text" id="color" placeholder="Red, Black..." list="color-list">
                </div>
                <div>
                    <label for="min_price">Min $</label>
                    <input type="text" id="min_price" maxlength="4" pattern="[0-9]*">
                </div>
                <div>
                    <label for="max_price">Max $</label>
                    <input type="text" id="max_price" maxlength="4" pattern="[0-9]*">
                </div>
                <div>
                    <label for="min_discount">Min %</label>
                    <input type="text" id="min_discount" maxlength="2" pattern="[0-9]*">
                </div>
                <div>
                    <label for="sort_by">Sort By</label>
                    <select id="sort_by">
                        <option value="discount">Discount</option>
                        <option value="price">Price</option>
                    </select>
                </div>
            </div>
        </form>
    </header>
    <datalist id="brand-list"></datalist>
    <datalist id="color-list"></datalist>
    <div id="nested-list"></div>
    <script>
        let allProducts = [],
            filteredProducts = [],
            groupedData = {};
        let isInitialLoad = true,
            groupObserver,
            sentinelObserver;
        let expandedGroupIds = new Set();
        const CHUNK_SIZE = 50;
        let sectionToCatMap = {};
        // Gender pre-filtering cache
        let genderFilteredProducts = [];
        let lastGender = '';
        // Track last filtered results to avoid unnecessary re-renders
        let lastFilteredProductIds = '';

        function debounce(func, delay) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function toggleSection(id) {
            const el = document.getElementById(id);
            if (!el) return;
            const isHidden = el.classList.toggle('hidden');
            const toggleIcon = document.querySelector(`[data-toggle="${id}"]`);
            if (toggleIcon) toggleIcon.textContent = isHidden ? '+' : '−';

            // Track expanded state
            if (isHidden) {
                expandedGroupIds.delete(id);
            } else {
                expandedGroupIds.add(id);
            }
        }

        function getCategoryPath(p) {
            const section = p.isGenderless ? 'everything-else' : p.gender;
            const catMap = sectionToCatMap[section];
            if (!catMap) return ['Unknown'];
            const names = p.allCategoryIds.map(id => catMap[Number(id)]?.name || 'Unknown');
            return names.length ? names : ['Uncategorized'];
        }

        const deepGet = (obj, path) => path.reduce((xs, x) => (xs && xs[x]) ? xs[x] : null, obj);

        function getSizeSortValue(size) {
            // For numeric sizes, return the number
            const num = parseFloat(size);
            if (!isNaN(num)) return num;

            // For letter sizes: XXXS -> XXS -> XS -> S -> M -> L -> XL -> XXL -> XXXL
            const upper = size.toUpperCase();

            // Special cases
            if (upper === 'ONE SIZE' || upper === 'OS') return 1000; // Put at end
            if (upper === 'M') return 100; // Medium in the middle

            // Count X's and check if it ends with S or L
            const xCount = (upper.match(/X/g) || []).length;
            if (upper.endsWith('S')) {
                // Smaller sizes: more X's = smaller (XXXS=97, XXS=98, XS=99, S=100)
                return 100 - xCount - 1;
            } else if (upper.endsWith('L')) {
                // Larger sizes: more X's = larger (L=101, XL=102, XXL=103, XXXL=104)
                return 100 + xCount + 1;
            }

            // Unknown format, put at end
            return 2000;
        }

        function getGroupedData(products) {
            let groups = {};
            const deepSet = (obj, path, value) => {
                let current = obj;
                // Navigate to the parent of the final segment
                for (let i = 0; i < path.length - 1; i++) {
                    const segment = path[i];
                    if (!current[segment]) {
                        current[segment] = {};
                    }
                    if (Array.isArray(current[segment])) return; // Can't traverse into arrays
                    current = current[segment];
                }
                // Initialize final segment as array if needed, then push
                const lastSegment = path[path.length - 1];
                if (!current[lastSegment]) {
                    current[lastSegment] = [];
                }
                if (Array.isArray(current[lastSegment])) {
                    current[lastSegment].push(value);
                }
            };

            products.forEach(p => {
                // Use pre-computed category path
                deepSet(groups, p.categoryPath, p);

                // Add product to 'ALL' subcategories at each level
                // For path ['Men', 'Clothing', 'Shirts'], creates:
                // ['Men', 'ALL'] and ['Men', 'Clothing', 'ALL']
                // Build path incrementally to avoid array spreading
                const allPath = [];
                for (let i = 0; i < p.categoryPath.length - 1; i++) {
                    allPath.push(p.categoryPath[i]);
                    if (p.categoryPath[i] !== 'ALL') {
                        allPath.push('ALL');
                        deepSet(groups, allPath, p);
                        allPath.pop(); // Remove 'ALL' for next iteration
                    }
                }
            });

            // Don't sort here - let renderLevel handle sorting at render time
            return groups;
        }

        function appendTableRows(tbody, products, startIndex, count) {
            const productsToShow = products.slice(startIndex, startIndex + count);
            const fragment = document.createDocumentFragment();
            productsToShow.forEach(p => {
                const tr = document.createElement('tr');
                const hue = Math.min(p.discount / 90, 1) * 120;
                const salePrice = p.lowest ? `$${Math.round(p.lowest)}` : '-';
                const regularPrice = p.regular ? `$${Math.round(p.regular)}` : '-';
                const brand = p.brand || 'N/A';
                const productName = p.name || '';
                const imageUrl = p.images?.[0] || '';
                const description = p.description || '';
                const imageWrapperData = `data-images='${p.imagesJson}' data-current-index="0"`;
                const imageContent = `<div class="image-wrapper" ${imageWrapperData}>${imageUrl ? `<img src="${imageUrl}" class="product-thumbnail" loading="lazy" alt="${p.name}">` : '<div class="lazy-image-placeholder"></div>'}</div>`;
                tr.innerHTML = `<td class="image-cell">${imageContent}</td><td class="discount" style="background-color:hsl(${hue},80%,85%)">${p.discount}%</td><td class="product-name"><a href="${p.url || '#'}" target="_blank" onclick="event.stopPropagation()" title="${p.name}">${productName}</a></td><td class="brand-name" title="${p.brand || 'N/A'}">${brand}</td><td class="description-cell" title="${description}"><div class="description-content">${p.descriptionEscaped}</div></td><td class="sizes-cell">${(p.sizes || []).join(', ')}</td><td class="price-cell">${salePrice}</td><td class="price-cell"><s>${regularPrice}</s></td>`;
                fragment.appendChild(tr);
            });
            tbody.appendChild(fragment);
        }

        function renderSkeletonUI() {
            const container = document.getElementById('nested-list');
            container.innerHTML = '';
            if (Object.keys(groupedData).length === 0) {
                container.innerHTML = '<p style="text-align:center; padding: 2rem;">No products match your criteria.</p>';
                return;
            }

            const createHeader = (level, groupId, toggleIcon, content) => {
                const header = document.createElement('div');
                header.className = 'group-header';
                header.style.marginLeft = `${level}rem`;
                header.style.fontWeight = level === 0 ? '600' : level === 1 ? '500' : '400';
                header.style.background = level % 2 === 0 ? 'var(--stripe-color)' : '#fff';
                header.onclick = () => toggleSection(groupId);
                header.innerHTML = `<span class="toggle" data-toggle="${groupId}">${toggleIcon}</span> ${content}`;
                return header;
            };

            const renderLevel = (subContainer, data, level, pathPrefix) => {
                // Always sort keys: 'ALL' first, then alphabetically
                const sortedKeys = Object.keys(data).sort((a, b) => {
                    if (a === 'ALL') return -1;
                    if (b === 'ALL') return 1;
                    return a.localeCompare(b);
                });

                const fragment = document.createDocumentFragment();
                sortedKeys.forEach(key => {
                    const value = data[key];
                    const currentPathArray = [...pathPrefix, key];
                    const groupId = 'group_' + btoa(JSON.stringify(currentPathArray));
                    const isExpanded = expandedGroupIds.has(groupId);
                    const toggleIcon = isExpanded ? '−' : '+';

                    if (Array.isArray(value)) {
                        const header = createHeader(level, groupId, toggleIcon, `${key} (${value.length})`);
                        fragment.appendChild(header);
                        const tableContainer = document.createElement('div');
                        tableContainer.id = groupId;
                        tableContainer.className = `product-table lazy-load-group ${isExpanded || 'hidden'}`;
                        tableContainer.style.marginLeft = `${level}rem`;
                        tableContainer.dataset.groupKey = JSON.stringify(currentPathArray);
                        fragment.appendChild(tableContainer);
                    } else {
                        // Non-leaf nodes always have an ALL subcategory with all descendant products
                        const childProductCount = value.ALL.length;
                        const header = createHeader(level, groupId, toggleIcon, `${key} (${childProductCount})`);
                        fragment.appendChild(header);
                        const innerContainer = document.createElement('div');
                        innerContainer.id = groupId;
                        innerContainer.className = isExpanded || 'hidden';
                        fragment.appendChild(innerContainer);
                        renderLevel(innerContainer, value, level + 1, currentPathArray);
                    }
                });
                subContainer.appendChild(fragment);
            };
            renderLevel(container, groupedData, 0, []);
        }

        function setupGroupObserver() {
            if (groupObserver) groupObserver.disconnect();
            const groupsToLoad = document.querySelectorAll('.lazy-load-group');
            if (groupsToLoad.length === 0) return;

            groupObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        const groupKeyPath = JSON.parse(container.dataset.groupKey);
                        const products = deepGet(groupedData, groupKeyPath);

                        if (products) {
                            const table = document.createElement('table');
                            table.innerHTML = '<thead><tr><th class="image">Image</th><th class="discount">Discount</th><th class="product-name">Product</th><th class="brand-name">Brand</th><th>Description</th><th class="sizes-cell">Sizes</th><th class="price-cell">Sale</th><th class="price-cell">Original</th></tr></thead>';
                            const tbody = document.createElement('tbody');
                            table.appendChild(tbody);

                            appendTableRows(tbody, products, 0, CHUNK_SIZE);
                            container.appendChild(table);

                            if (products.length > CHUNK_SIZE) {
                                const sentinel = document.createElement('div');
                                sentinel.className = 'load-sentinel';
                                sentinel.dataset.groupKey = container.dataset.groupKey;
                                sentinel.dataset.nextIndex = CHUNK_SIZE;
                                container.appendChild(sentinel);
                                sentinelObserver.observe(sentinel);
                            }
                        }
                        container.classList.remove('lazy-load-group');
                        observer.unobserve(container);
                    }
                });
            }, {
                rootMargin: '200px'
            });
            groupsToLoad.forEach(group => groupObserver.observe(group));
        }

        function parseInput(id, transform = v => v) {
            return document.getElementById(id).value.split(',').map(s => transform(s.trim())).filter(Boolean);
        }

        function applyFiltersAndRender() {
            // Clear expanded groups only on initial load
            if (isInitialLoad) {
                expandedGroupIds.clear();
            }
            // Otherwise preserve the expandedGroupIds Set (already tracked in toggleSection)

            const brand = parseInput('brand', s => s.toLowerCase());
            const color = parseInput('color', s => s.toLowerCase());
            const size = parseInput('size', s => s.match(/[\d.]+/)?.[0] || s.trim().toUpperCase());
            const gender = document.getElementById('gender').value;
            const sortBy = document.getElementById('sort_by').value;
            const minDiscount = parseFloat(document.getElementById('min_discount').value) || 0;
            const minPrice = parseFloat(document.getElementById('min_price').value) || 0;
            const maxPrice = parseFloat(document.getElementById('max_price').value) || Infinity;

            // Pre-filter by gender (cache since it rarely changes)
            if (gender !== lastGender) {
                genderFilteredProducts = allProducts.filter(p =>
                    gender === 'other' ? p.isGenderless : (p.gender === gender && !p.isGenderless)
                );
                lastGender = gender;
            }

            // Cache filter array lengths outside the loop
            const hasBrandFilter = brand.length > 0;
            const hasColorFilter = color.length > 0;
            const hasSizeFilter = size.length > 0;

            // Order filters by selectivity (most selective first) for early short-circuit
            // Now filtering the smaller gender-filtered subset instead of all 100k products
            filteredProducts = genderFilteredProducts.filter(p => {
                // Brand is most selective
                if (hasBrandFilter && (!p.brandLower || !brand.some(b => p.brandLower.startsWith(b)))) return false;
                // Size is second most selective
                if (hasSizeFilter && !size.some(s => (p.sizes || []).includes(s))) return false;
                // Color is third most selective
                if (hasColorFilter && (!p.colorLower || !color.some(c => p.colorLower.includes(c)))) return false;
                // Price and discount are less selective (checked last)
                if (p.lowest < minPrice || p.lowest > maxPrice) return false;
                if (p.discount < minDiscount) return false;
                return true;
            });

            filteredProducts.sort((a, b) => sortBy === 'price' ? a.lowest - b.lowest : b.discount - a.discount);

            // Check if filtered results actually changed to avoid unnecessary re-renders
            const currentFilteredIds = filteredProducts.length + ':' +
                filteredProducts.slice(0, 10).map(p => p.productCode).join(',');

            if (currentFilteredIds === lastFilteredProductIds) {
                return; // Results unchanged, skip re-render to prevent image flickering
            }
            lastFilteredProductIds = currentFilteredIds;

            groupedData = getGroupedData(filteredProducts);

            renderSkeletonUI();
            setupGroupObserver();

            isInitialLoad = false;
        }

        async function initialDataFetch() {
            document.getElementById('progress-container').style.display = 'block';
            try {
                const [productsRes, categoriesRes] = await Promise.all([
                    fetch('/products.json.br'),
                    fetch('/categories.json.br')
                ]);
                if (!productsRes.ok) throw new Error(`HTTP error! status: ${productsRes.status}`);
                if (!categoriesRes.ok) throw new Error(`HTTP error! status: ${categoriesRes.status}`);
                allProducts = await productsRes.json();

                // Normalize and pre-compute values for cleaner display and faster filtering
                allProducts.forEach(p => {
                    // Normalize and sort sizes
                    if (p.sizes) {
                        p.sizes = p.sizes
                            .map(size => {
                                // If size contains a number, extract just the numeric part (e.g., "8.5 US" -> "8.5")
                                // Otherwise keep alphabetic sizes as-is (e.g., "XS", "ONE SIZE")
                                return size.match(/[\d.]+/)?.[0] || size.trim();
                            })
                            .sort((a, b) => getSizeSortValue(a) - getSizeSortValue(b));
                    }
                    // Pre-compute lowercase for filtering
                    p.brandLower = p.brand ? p.brand.toLowerCase() : '';
                    p.colorLower = p.color ? p.color.toLowerCase() : '';
                    // Pre-compute JSON-stringified images for data attributes
                    p.imagesJson = JSON.stringify(p.images || []);
                    // Pre-compute HTML-escaped description
                    const desc = p.description || '';
                    p.descriptionEscaped = desc.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                });

                const categoriesData = await categoriesRes.json();

                sectionToCatMap = {
                    men: {},
                    women: {},
                    'everything-else': {}
                };

                Object.keys(categoriesData).forEach(section => {
                    const cats = categoriesData[section];
                    const map = sectionToCatMap[section];

                    function traverse(catArr) {
                        catArr.forEach(cat => {
                            map[cat.id] = {
                                name: cat.name,
                                seoKeyword: cat.seoKeyword,
                                level: cat.level
                            };
                            if (cat.children) traverse(cat.children);
                        });
                    }
                    traverse(cats);
                });

                // Pre-compute category paths now that sectionToCatMap is ready
                allProducts.forEach(p => {
                    p.categoryPath = getCategoryPath(p);
                });

                const populateDatalist = (listId, values) => {
                    const list = document.getElementById(listId);
                    const fragment = document.createDocumentFragment();
                    values.forEach(value => {
                        const option = document.createElement('option');
                        option.value = value;
                        fragment.appendChild(option);
                    });
                    list.appendChild(fragment);
                };

                populateDatalist('brand-list', [...new Set(allProducts.map(p => p.brand))].sort());
                populateDatalist('color-list', [...new Set(allProducts.map(p => p.color).filter(Boolean))].sort());

                applyFiltersAndRender();
            } catch (error) {
                console.error('Failed to fetch product data:', error);
                document.getElementById('nested-list').innerHTML = '<p style="text-align: center; color: red; padding: 2rem;">Error loading data. Please try again.</p>';
            } finally {
                document.getElementById('progress-container').style.display = 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const debouncedApplyFilters = debounce(applyFiltersAndRender, 100);
            document.querySelectorAll('#filters select, #filters input').forEach(el => {
                el.addEventListener('change', applyFiltersAndRender);
                el.addEventListener('input', debouncedApplyFilters);
            });

            sentinelObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const sentinel = entry.target;
                        const groupKeyPath = JSON.parse(sentinel.dataset.groupKey);
                        const nextIndex = parseInt(sentinel.dataset.nextIndex, 10);
                        const products = deepGet(groupedData, groupKeyPath);
                        const table = sentinel.previousElementSibling;
                        const tbody = table.querySelector('tbody');

                        if (products && tbody) {
                            appendTableRows(tbody, products, nextIndex, CHUNK_SIZE);
                            const newNextIndex = nextIndex + CHUNK_SIZE;

                            if (newNextIndex >= products.length) {
                                observer.unobserve(sentinel);
                                sentinel.remove();
                            } else {
                                sentinel.dataset.nextIndex = newNextIndex;
                            }
                        }
                    }
                });
            }, {
                rootMargin: '400px'
            });

            document.getElementById('nested-list').addEventListener('click', e => {
                if (e.target.classList.contains('product-thumbnail')) {
                    const clickedWrapper = e.target.parentElement;
                    const isExpanding = !clickedWrapper.classList.contains('expanded');
                    const previouslyExpandedWrapper = document.querySelector('.image-wrapper.expanded');

                    if (previouslyExpandedWrapper) {
                        previouslyExpandedWrapper.classList.remove('expanded');
                        previouslyExpandedWrapper.style.transform = ''; // Clear adjustments
                        manageImageNav(previouslyExpandedWrapper, false);
                    }

                    if (isExpanding && clickedWrapper !== previouslyExpandedWrapper) {
                        clickedWrapper.classList.add('expanded');
                        manageImageNav(clickedWrapper, true);

                        requestAnimationFrame(() => {
                            const header = document.querySelector('.site-header');
                            const headerHeight = header ? header.getBoundingClientRect().height : 0;
                            const rect = clickedWrapper.getBoundingClientRect();
                            const viewportHeight = window.innerHeight;
                            let adjustment = 0;
                            const margin = 10;

                            if (rect.top < headerHeight + margin) {
                                adjustment = (headerHeight + margin) - rect.top;
                            } else if (rect.bottom > viewportHeight - margin) {
                                adjustment = (viewportHeight - margin) - rect.bottom;
                            }

                            if (adjustment !== 0) {
                                clickedWrapper.style.transform = `translateY(-50%) translateY(${adjustment}px)`;
                            }
                        });

                    } else if (!isExpanding) {
                        const thumbnail = clickedWrapper.querySelector('.product-thumbnail');
                        const images = JSON.parse(clickedWrapper.dataset.images || '[]');
                        if (images.length > 0) {
                            thumbnail.src = images[0];
                            clickedWrapper.dataset.currentIndex = "0";
                        }
                    }
                }
            });

            initialDataFetch();
        });

        function manageImageNav(wrapper, shouldShow) {
            wrapper.querySelectorAll('.image-nav-arrow').forEach(arrow => arrow.remove());
            if (!shouldShow) return;
            const images = JSON.parse(wrapper.dataset.images || '[]');
            if (images.length <= 1) return;
            const createArrow = (direction) => {
                const arrow = document.createElement('button');
                arrow.className = `image-nav-arrow ${direction}`;
                arrow.innerHTML = direction === 'left' ? '&#10094;' : '&#10095;';
                arrow.onclick = (e) => {
                    e.stopPropagation();
                    const currentIndex = parseInt(wrapper.dataset.currentIndex, 10);
                    const totalImages = images.length;
                    const newIndex = (currentIndex + (direction === 'left' ? -1 : 1) + totalImages) % totalImages;
                    wrapper.dataset.currentIndex = newIndex;
                    wrapper.querySelector('img.product-thumbnail').src = images[newIndex];
                };
                wrapper.appendChild(arrow);
            };
            ['left', 'right'].forEach(createArrow);
        }
    </script>
</body>
</html>